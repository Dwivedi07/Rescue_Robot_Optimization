# -*- coding: utf-8 -*-
"""NCMDAO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xGyeMjCoa8sBrlJ4OJaDfQEnv4aEYw7A
"""

!pip install opencv-python-headless shapely
!pip install simplification

import cv2
import numpy as np
from google.colab import files
from simplification.cutil import simplify_coords
from shapely.geometry import Polygon
import matplotlib.pyplot as plt

# Step 1: Upload the image using Google Colab's file uploader
uploaded = files.upload()

# Step 2: Load and preprocess the uploaded image
for filename in uploaded.keys():
    image = cv2.imdecode(np.fromstring(uploaded[filename], dtype=np.uint8), -1)

# Preprocess the image as needed (resize, grayscale, etc.)
# Example: Convert to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Step 3: Extract Boundaries
# Apply Canny edge detection
edges = cv2.Canny(gray_image, threshold1=100, threshold2=200)

# Find contours from the edges
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Assuming you have one main boundary, select the largest contour
main_boundary = max(contours, key=cv2.contourArea)

# Step 4: Simplify Boundaries
# Define the number of points you want (N)
N = 100

# Simplify the boundary to N points using RDP
simplified_boundary = simplify_coords(np.vstack(main_boundary), N)

# Step 5: Store and Visualize Results
# Store the simplified boundary as a list of coordinates
simplified_coordinates = simplified_boundary.tolist()

# Visualize the results using Shapely and Matplotlib
# Original boundary as a Shapely Polygon
original_polygon = Polygon(main_boundary.squeeze())

# Simplified boundary as a Shapely Polygon
simplified_polygon = Polygon(simplified_coordinates)

# Plot the original and simplified boundaries
fig, ax = plt.subplots(1, 2, figsize=(12, 6))
ax[0].set_title("Original Boundary")
ax[1].set_title(f"Simplified Boundary (N={N})")
ax[0].plot(*original_polygon.exterior.xy)
ax[1].plot(*simplified_polygon.exterior.xy)
plt.show()

import numpy as np
from shapely.geometry import Polygon, Point
from scipy.spatial import Delaunay
import matplotlib.pyplot as plt

# Define your polygon using coordinates
polygon_coords = [(0, 0), (0, 10), (10, 10), (10, 0)]

# Create a Shapely polygon from the coordinates
polygon = Polygon(polygon_coords)

# Define the number of random points to generate within the polygon
num_points = 5  # Adjust this as per your requirement

# Generate random points within the polygon
points = []
while len(points) < num_points:
    random_point = Point(np.random.uniform(0, 10), np.random.uniform(0, 10))  # Adjust the bounds based on your polygon
    if polygon.contains(random_point):
        points.append((random_point.x, random_point.y))

# Convert points to a numpy array for Delaunay triangulation
points_array = np.array(points)

# Perform Delaunay triangulation
triangulation = Delaunay(points_array)

# Extract the triangles
triangles = points_array[triangulation.simplices]

# Plot the Delaunay triangulation
plt.triplot(points_array[:,0], points_array[:,1], triangulation.simplices)
plt.plot(points_array[:,0], points_array[:,1], 'o')
plt.xlim(0, 10)  # Adjust this based on your polygon dimensions
plt.ylim(0, 10)  # Adjust this based on your polygon dimensions
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

import numpy as np
from shapely.geometry import Polygon
from scipy.spatial import Delaunay
import matplotlib.pyplot as plt

# Define your fixed polygon using coordinates
polygon_coords = [(0, 0), (0, 10), (10, 10), (10, 0)]

# Create a Shapely polygon from the coordinates
polygon = Polygon(polygon_coords)

# Perturb the polygon vertices slightly to introduce stochasticity
perturbation_scale = 0.2  # Adjust this for the amount of perturbation
perturbed_coords = [(x + np.random.uniform(-perturbation_scale, perturbation_scale),
                     y + np.random.uniform(-perturbation_scale, perturbation_scale))
                    for x, y in polygon_coords]

# Create a new Shapely polygon with perturbed vertices
perturbed_polygon = Polygon(perturbed_coords)

# Define the number of random points to generate within the perturbed polygon
num_points = 30  # Adjust this as per your requirement

# Generate random points within the perturbed polygon
points = []
while len(points) < num_points:
    x = np.random.uniform(0, 10)  # Adjust the bounds based on your polygon
    y = np.random.uniform(0, 10)  # Adjust the bounds based on your polygon
    random_point = (x, y)
    if perturbed_polygon.contains(Point(random_point)):
        points.append(random_point)

# Convert points to a numpy array for Delaunay triangulation
points_array = np.array(points)

# Perform Delaunay triangulation
triangulation = Delaunay(points_array)

# Extract the triangles
triangles = points_array[triangulation.simplices]

# Plot the Delaunay triangulation
plt.triplot(points_array[:,0], points_array[:,1], triangulation.simplices)
plt.plot(points_array[:,0], points_array[:,1], 'o')
plt.xlim(0, 10)  # Adjust this based on your polygon dimensions
plt.ylim(0, 10)  # Adjust this based on your polygon dimensions
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

import numpy as np
from shapely.geometry import Polygon, Point
from scipy.spatial import Delaunay
import matplotlib.pyplot as plt

np.random.seed(42)

# Define your fixed polygon (cross sign shape) using coordinates
polygon_coords = [(5,5), (95,5), (95,25), (25, 25), (95,75), (95,95), (5,95), (5,75), (75,75), (5,25)]

# Create a Shapely polygon from the coordinates
polygon = Polygon(polygon_coords)

# Define the number of iterations (number of Voronoi diagrams)
num_iterations = 2

# Initialize a list to store the Voronoi diagrams
voronoi_diagrams = []

for _ in range(num_iterations):
    # Define the number of random points to generate within the polygon
    num_points = 20  # Adjust this as per your requirement for each iteration

    # Generate random points within the polygon
    points = []
    while len(points) < num_points:
        x = np.random.uniform(0, 100)  # Adjust the bounds based on your polygon
        y = np.random.uniform(0, 100)  # Adjust the bounds based on your polygon
        random_point = Point(x, y)
        if polygon.contains(random_point):
            points.append((random_point.x, random_point.y))

    # Convert points to a numpy array for Delaunay triangulation
    points_array = np.array(points)

    # Perform Delaunay triangulation
    triangulation = Delaunay(points_array)

    # Append the Delaunay triangulation to the list of Voronoi diagrams
    voronoi_diagrams.append(triangulation)

# You now have a list of Delaunay triangulations for the same fixed polygon
iteration_index = 1  # 0-based index for the 75th iteration
triangulation = voronoi_diagrams[iteration_index]
points = triangulation.points
triangles = points[triangulation.simplices]

# Plot the fixed polygon
polygon_coords = np.array(polygon.exterior)

# Plot the Voronoi diagram for the 75th iteration
plt.triplot(points[:, 0], points[:, 1], triangulation.simplices, label='Voronoi Triangulation')
plt.plot(points[:, 0], points[:, 1], 'o', markersize=5, color='red', label='Random Points')  # Plot the points
polygon_coords = [(5,5), (95,5), (95,25), (25, 25), (95,75), (95,95), (5,95), (5,75), (75,75), (5,25)]

x_coords, y_coords = zip(*polygon_coords)

# Close the polygon by adding the first point to the end
x_coords = np.append(x_coords, x_coords[0])
y_coords = np.append(y_coords, y_coords[0])
plt.plot(x_coords, y_coords, '-k', linewidth=2, label='Polygon')
# Plot the polygon
plt.figure(figsize=(8, 8))


# # Set axis limits and labels
# plt.xlim(0, 100)  # Adjust this based on your polygon dimensions
# plt.ylim(0, 100)  # Adjust this based on your polygon dimensions
# plt.gca().set_aspect('equal', adjustable='box')
# plt.title(f'Polygon and Voronoi Diagram - Iteration {iteration_index + 1}')
# plt.xlabel('X-axis')
# plt.ylabel('Y-axis')
# plt.grid(True)

# Add a legend
plt.legend()

# Show the plot
plt.show()

import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt

# Define the polygon coordinates
polygon_coords = [(5, 5), (95, 5), (95, 25), (25, 25), (95, 75), (95, 95), (5, 95), (5, 75), (75, 75), (5, 25)]

# Convert the polygon coordinates to a numpy array
polygon_coords = np.array(polygon_coords)

# Compute the Voronoi diagram
vor = Voronoi(polygon_coords)

# Plot the Voronoi diagram
voronoi_plot_2d(vor, show_vertices=False, show_points=True)

# Plot the polygon
polygon_coords = np.append(polygon_coords, [polygon_coords[0]], axis=0)
plt.plot(polygon_coords[:, 0], polygon_coords[:, 1], 'k-')

# Set axis limits and labels
plt.xlim(0, 100)  # Adjust this based on your polygon dimensions
plt.ylim(0, 100)  # Adjust this based on your polygon dimensions
plt.gca().set_aspect('equal', adjustable='box')
plt.title('Voronoi Diagram with Polygon')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')

# Show the plot
plt.show()

import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
import random
from shapely.geometry import Polygon, Point

import numpy as np

def generate_evenly_distributed_points(x, N):
    # Calculate the interval between points
    interval = x / np.sqrt(N)

    # Initialize a list to store the points as tuples
    points = []

    # Generate evenly distributed points
    for i in range(int(np.sqrt(N))):
        for j in range(int(np.sqrt(N))):
            x_coord = i * interval + interval / 2
            y_coord = j * interval + interval / 2
            points.append((x_coord, y_coord))

    return points

# Size of the square
x = 100  # Replace with your desired size

# Number of points to generate
N = 200  # Replace with your desired number of points

# Generate evenly distributed points
points_new = generate_evenly_distributed_points(x, N)

original_polygon_coords = [(5, 5), (95, 5), (95, 25), (25, 25), (95, 75), (95, 95), (5, 95), (5, 75), (75, 75), (5, 25)]
polygon = Polygon(original_polygon_coords)

# Shuffle the points randomly
random.shuffle(points_new)

# Initialize a list to store points inside the polygon
selected_points = []

# Iterate through the shuffled points and select p points inside the polygon
p = 20 # Replace with your desired number of points
for point in points_new:
    if polygon.contains(Point(point)):
        selected_points.append(point)
        if len(selected_points) == p:
            break

# Define the original polygon coordinates
polygon_coords = [(5, 5), (95, 5), (95, 25), (25, 25), (95, 75), (95, 95), (5, 95), (5, 75), (75, 75), (5, 25)]

# Define seed points within a specific region to create smaller subspaces
seed_points = points_new
# Combine the original polygon coordinates and the seed points
combined_points = np.vstack((polygon_coords, seed_points))

# Compute the Voronoi diagram
vor = Voronoi(combined_points)

# Plot the Voronoi diagram
voronoi_plot_2d(vor, show_vertices=False, show_points=True)

# Plot the original polygon
polygon_coords = np.append(polygon_coords, [polygon_coords[0]], axis=0)
plt.plot(polygon_coords[:, 0], polygon_coords[:, 1], 'k-')

# Set axis limits and labels
plt.xlim(0, 100)  # Adjust this based on your polygon dimensions
plt.ylim(0, 100)  # Adjust this based on your polygon dimensions
plt.gca().set_aspect('equal', adjustable='box')
plt.title('Voronoi Diagram with Smaller Subspaces')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')

# Show the plot
plt.show()

import numpy as np
from scipy.spatial import Voronoi

# Define the original polygon coordinates
polygon_coords = [(5, 5), (95, 5), (95, 25), (25, 25), (95, 75), (95, 95), (5, 95), (5, 75), (75, 75), (5, 25)]

# Compute the Voronoi diagram
vor = Voronoi(polygon_coords)

# Extract the Voronoi ridge points and regions
ridge_points = vor.ridge_points
regions = vor.regions

# Compute centroids of the Voronoi cells without seed points
cell_centroids = []

# Iterate through regions
for region in regions:
    if -1 not in region and len(region) > 0:
        vertices = vor.vertices[region]
        centroid_x = np.mean(vertices[:, 0])
        centroid_y = np.mean(vertices[:, 1])
        cell_centroids.append((centroid_x, centroid_y))

# Display the centroids
for i, centroid in enumerate(cell_centroids):
    print(f"Centroid {i + 1}: {centroid}")

import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt

# Define the original polygon coordinates
polygon_coords = [(5, 5), (95, 5), (95, 25), (25, 25), (95, 75), (95, 95), (5, 95), (5, 75), (75, 75), (5, 25)]

# Compute the Voronoi diagram
vor = Voronoi(polygon_coords)

# Extract the Voronoi ridge points and regions
ridge_points = vor.ridge_points
regions = vor.regions

# Compute centroids of the Voronoi cells without seed points
cell_centroids = []

# Iterate through regions
for region in regions:
    if -1 not in region and len(region) > 0:
        vertices = vor.vertices[region]
        centroid_x = np.mean(vertices[:, 0])
        centroid_y = np.mean(vertices[:, 1])
        cell_centroids.append((centroid_x, centroid_y))

# Plot the Voronoi diagram
voronoi_plot_2d(vor, show_vertices=False, show_points=True)

# Plot the centroids
centroids = np.array(cell_centroids)
plt.scatter(centroids[:, 0], centroids[:, 1], marker='o', s=50, c='red', label='Centroids')

# Plot the original polygon
polygon_coords = np.append(polygon_coords, [polygon_coords[0]], axis=0)
plt.plot(polygon_coords[:, 0], polygon_coords[:, 1], 'k-')

# Set axis limits and labels
plt.xlim(0, 100)  # Adjust this based on your polygon dimensions
plt.ylim(0, 100)  # Adjust this based on your polygon dimensions
plt.gca().set_aspect('equal', adjustable='box')
plt.title('Voronoi Diagram with Centroids')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')

# Add a legend
plt.legend()

# Show the plot
plt.show()